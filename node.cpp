#include"node.h"
#include<fstream>
#include<iostream>
#include<stdio.h>
#include<cstdlib>
#include<algorithm>
#include<set>

node::node(int a){
	val=a;
	parrent=right=left=0;
}

tree::tree(std::vector<int> arr){
        file.open("bintree.dot");
        file<<"#This file is automatically generated. Use the bin file.\n";
        file <<"digraph BinTree{\n";
	std::vector<int>values= get_sred(arr);
	root=new node(values[0]);
	for(int i=1;i<values.size();++i){
                 add_elem(values[i]);
        }   

	
}

void tree::replace(node *a, node *b){
	node *swap;
	swap=new node(0);
	swap->right =a->right;
	swap->left=a->left;
	swap->parrent=a->parrent;
	swap->val=a->val;
	
        a->right =b->right;
        a->left=b->left;
        a->parrent=b->parrent;
    	a->val=b->val;
	
        b->right =swap->right;
        b->left=swap->left;
        b->parrent=swap->parrent;
	b->val=swap->val;
	delete swap;
 }


node *tree::get_root(){
	return root;
}
void tree::add_elem(int val){
	add_elem(root,val);
}


void tree::add_elem(node *r,int val){
        if (val==r->val)return;
        if(val>r->val){
                if(!r->right){
                        r->right=new node(val);
			r->right->parrent=r;
                }else{
                        add_elem(r->right, val);
                }   
        }else{
                if(r->left==0){
                        r->left= new node (val);
			r->left->parrent=r;
                }else{
                        add_elem(r->left,val);
                }
        }
}

node *tree::find(int val){
	return find(root,val);
}


node *tree::find(node *r, int val){
        if(!r)return 0;
	if(r->val==val)return r;
	if(r->val>val)return find(r->left,val);
        if(r->val<val)return find(r->right,val);
}
void tree::Print(){
	Print(root);
}

void tree::Print(node *p){    
        if (p){
                Print(p->left);
                if(p->left){
                file<<p->val<<" -> "<<p->left->val<<";\n";}
                if(p->right){
                file<<p->val<<" -> "<<p->right->val<<";\n";}
                Print(p->right);    
                }    
}
bool tree::delete_elem( int val){
	std::vector<int>values=get_val_of_node(find(val));
	delete_node(find(val));
	for(int i=1;i<values.size();++i){
		add_elem(values[i]);
	}
}	

std::vector<int> tree::get_val_of_node(node *p){
	static std::vector<int>vals;
	if (p){
		vals.push_back(p->val);
            	get_val_of_node(p->left);
                get_val_of_node(p->right);
        }
	return vals;
}

	


void tree::delete_node(node *r){
	if(r){	
		if(r->left)delete_node(r->left);
		if (r->right)delete_node(r->right);
		if((r->parrent!=0)&&(r->parrent->left==r)){
			r->parrent->left=0;
		}else{
			if((r->parrent!=0)&&(r->parrent->right==r)){
				r->parrent->right=0;}
			}
		delete r;
		return;
	}
}

tree::~tree(){
        file <<"}\n";
        file.close();
        if(!system("dot -Tpng bintree.dot -o bintree.png")){
                 std::cout<<"\nTree is build\nIMG:\tbintree.png\nSOURCE:\tbintree.dot\n";
	}
	delete_node(root);
}

std::vector<int> tree::get_sred(std::vector<int> a){
	static std::vector<int> val;
        std::set<int> c(a.begin(),a.end());
        std::vector<int> b(c.begin(),c.end());
        std::sort(b.begin(),b.end());
        if (b.size()>1){
        std::vector<int>b1(b.begin(),b.begin()+b.size()/2+b.size()%2-1);
        std::vector<int>b2(b.begin()+b.size()/2+b.size()%2-1+1,b.end());     
                val.push_back(b[b.size()/2+b.size()%2-1]);
                if(b1.size())get_sred(b1);
                if(b2.size())get_sred(b2);
        }else{
                val.push_back(b[0]);
        }
	return val;
}

